\section{Instruction Tables}

\begin{table}[ht]
    \begin{center}
        \begin{tabular}{|c|c|c|c|c|}
            \hline
            class & funct7 & funct3 & instruction & operation \\
            \hline
            \multirow{10}{*}{OP} & 0000000 & 000 & ADD & addition\\
            & 0100000 & 000 & SUB & subtraction\\
            & 0000000 & 001 & SLL & left logic shift\\
            & 0000000 & 010 & SLT & set if less than\\
            & 0000000 & 011 & SLTU & set if less than unsigned\\
            & 0000000 & 100 & XOR & bit-wise EXOR\\
            & 0000000 & 101 & SRL & right logic shift\\
            & 0100000 & 101 & SRA & right arithmetic shift\\
            & 0000000 & 110 & OR & bit-wise OR\\
            & 0000000 & 111 & AND & bit-wise AND\\
            \hline
            \multirow{9}{*}{OP-IMM} & - & 000 & ADDI & addition\\
            & 0000000 & 001 & SLLI & left logic shift\\
            & - & 010 & SLTI & set if less than\\
            & - & 011 & SLTIU & set if less than unsigned\\
            & - & 100 & XORI & bit-wise EXOR\\
            & 0000000 & 101 & SRLI & right logic shift\\
            & 0100000 & 101 & SRAI & right arithmetic shift\\
            & - & 110 & ORI & bit-wise OR\\
            & - & 111 & ANDI & bit-wise AND\\
            \hline
            \multirow{3}{*}{STORE} & - & 000 & SB & addition\\
            & - & 001 & SH & addition\\
            & - & 010 & SW & addition\\
            \hline
            \multirow{5}{*}{LOAD} & - & 000 & LB & addition\\
            & - & 001 & LH & additionn\\
            & - & 010 & LW & addition\\
            & - & 100 & LBU & unsigned addition\\
            & - & 101 & LHU & unsigned addition\\
            \hline
            JALR & - & 000 & JALR & addition\\
            \hline
            JAL & - & - & JAL & addition\\
            \hline
            LUI & - & - & LUI (pseudo instruction LI) & addition with x0\\
            \hline
            AUIPC & - & - & AUIPC & addition\\
            \hline
            \multirow{6}{*}{BRANCH} & - & 000 & BEQ & branch if equal\\
            & - & 001 & BNE & branch if not equal\\
            & - & 100 & BLT & branch if lower than\\
            & - & 101 & BGE & branch if greater or equal\\
            & - & 110 & BLTU & branch if lower than unsigned\\
            & - & 111 & BGEU & branch if greater or equal unsigned\\
            \hline
        \end{tabular}
        \caption{RV32I core instructions}
        \label{table:core_instr}
    \end{center}
\end{table}

\section{Code segments}
\subsection{Instruction Fetch [RV32I]}
\subsubsection{Base architecture}
\begin{code}
\captionof{listing}{Architecure of the Instruction Fetch}
\label{code:IF_code}   

\begin{minted}[fontsize=\footnotesize]{vhdl}
entity instr_fetch is
port ( 
    clk         : in std_logic;
    pc_load_en  : in std_logic;
    pc_in       : in std_logic_vector(11 downto 0);
    
    next_pc     : out std_logic_vector(11 downto 0);
    curr_pc     : out std_logic_vector(11 downto 0);
    instr       : out std_logic_vector(31 downto 0));
end instr_fetch;

architecture Structural of instr_fetch is
signal pc_reg  : unsigned(11 downto 0) := (others => '0');

component instruction_memory
port(
    clka        : in std_logic;
    wea         : in std_logic;
    addra       : in std_logic_vector(9 downto 0);
    dina        : in std_logic_vector(31 downto 0);
    douta       : out std_logic_vector(31 downto 0));
end component;
begin
instr_mem: instruction_memory 
port map(
    clka        => clk,
    wea         => '0',
    dina        => (others => '0'),
    addra       => std_logic_vector(pc_reg(11 downto 2)),
    douta       => instr);

process (clk)
begin
    if rising_edge(clk) then
        if pc_load_en = '1' then
            pc_reg  <= unsigned(pc_in);
        end if;
    end if;
end process;
next_pc     <= std_logic_vector(pc_reg + 4);
curr_pc     <= std_logic_vector(pc_reg);
end Structural;
\end{minted}
\end{code}
\newpage


\subsubsection{Testbench}
\begin{code}
\captionof{listing}{first Instruction Fetch testbench}
\label{code:IF_TB}
\begin{minted}[fontsize=\footnotesize]{vhdl}
entity IF_testbench is
end IF_testbench;

architecture Behavioral of IF_testbench is
constant clk_period     : time := 20 ns;
signal pc_in            : std_logic_vector(11 downto 0) := (others => '0');
signal next_pc          : std_logic_vector(11 downto 0) := (others => '0');
signal curr_pc          : std_logic_vector(11 downto 0) := (others => '0');
signal instr            : std_logic_vector(31 downto 0) := (others => '0');
signal clk              : std_logic := '0';
signal pc_load_en       : std_logic := '1';

component instr_fetch
port ( 
    clk             : in std_logic;
    pc_load_en      : in std_logic;
    pc_in           : in std_logic_vector(11 downto 0);
    
    next_pc         : out std_logic_vector(11 downto 0);
    curr_pc         : out std_logic_vector(11 downto 0);
    instr           : out std_logic_vector(31 downto 0));
end component;
begin
if_inst : instr_fetch
port map (
    clk         => clk,
    pc_load_en  => pc_load_en,
    pc_in       => pc_in,
    next_pc     => next_pc,
    curr_pc     => curr_pc,
    instr       => instr);

process
begin
    clk <= '0';
    wait for clk_period / 2;
    clk <= '1';
    wait for clk_period / 2;
end process;

pc_in       <= next_pc_reg;
end Behavioral;
\end{minted}
\end{code}
\newpage


\subsection{Instruction Decode [RV32I]}
\subsubsection{Base architecture}
\begin{code}
\captionof{listing}{Base Instruction Decode}
\label{code:ID_code}  
\begin{minted}[fontsize=\footnotesize]{vhdl}
entity instr_decode is
    Port (
    clk         : in std_logic;
    instr       : in std_logic_vector(31 downto 0);
    next_pc     : in std_logic_vector(11 downto 0);
    curr_pc     : in std_logic_vector(11 downto 0);
    
    -- Inputs from mem writeback
    
    rd_write_en : in std_logic;
    rd_value    : in std_logic_vector(31 downto 0);
    
    -- sign-extended pc info
    
    next_pc_ze  : out std_logic_vector(31 downto 0);
    curr_pc_ze  : out std_logic_vector(31 downto 0);
    
    -- Decoded instruction informations
    
    op_class    : out std_logic_vector(4 downto 0);
    funct3      : out std_logic_vector(2 downto 0);
    funct7      : out std_logic_vector(6 downto 0);
    a_sel       : out std_logic;
    b_sel       : out std_logic;
    cond_opcode : out std_logic_vector(2 downto 0);
    
    -- Data to be elaborated
    
    rs1         : out std_logic_vector(31 downto 0);
    rs2         : out std_logic_vector(31 downto 0);
    imm_se      : out signed(31 downto 0));
end instr_decode;

architecture Structural of instr_decode is
signal rd_rs1_mux       : std_logic_vector(4 downto 0) := (others => '0');
signal next_pc_ze_reg   : std_logic_vector(31 downto 0) := (others => '0');
signal curr_pc_ze_reg   : std_logic_vector(31 downto 0) := (others => '0');
    
component register_file is
port(
    clk     : in std_logic;
    we      : in std_logic;
    a       : in std_logic_vector(4 downto 0);
    d       : in std_logic_vector(31 downto 0);
    dpra    : in std_logic_vector(4 downto 0);
    qspo    : out std_logic_vector(31 downto 0);
    qdpo    : out std_logic_vector(31 downto 0) );
end component;

component decoder is
port(
    clk         : in std_logic;
    instr       : in std_logic_vector(31 downto 0);
    op_class    : out std_logic_vector(4 downto 0);
    funct3      : out std_logic_vector(2 downto 0);
    funct7      : out std_logic_vector(6 downto 0);
    a_sel       : out std_logic;
    b_sel       : out std_logic;
    cond_opcode : out std_logic_vector(2 downto 0);
    imm_se      : out std_logic_vector(31 downto 0));
end component;
begin
reg : register_file
port map(
    clk         => clk,
    we          => rd_write_en,
    d           => rd_value,
    a           => rd_rs1_mux,
    dpra        => instr(24 downto 20),
    qspo        => rs1,
    qdpo        => rs2);

dec : decoder
port map(
    clk         => clk,
    instr       => instr,
    op_class    => op_class,
    funct3      => funct3,
    funct7      => funct7,
    a_sel       => a_sel,
    b_sel       => b_sel,
    cond_opcode => cond_opcode,
    imm_se      => imm_se);

process(clk)
begin
    if rising_edge(clk) then
        next_pc_ze_reg       <= std_logic_vector(resize(unsigned(next_pc), next_pc_ze_reg'length));
        curr_pc_ze_reg       <= std_logic_vector(resize(unsigned(curr_pc), next_pc_ze_reg'length));
    end if;
end process;

rd_rs1_mux  <= instr(11 downto 7) when rd_write_en = '1' else instr(19 downto 15);
next_pc_ze  <= next_pc_ze_reg;
curr_pc_ze  <= curr_pc_ze_reg;
end Structural;
\end{minted}
\end{code}

\subsubsection{Decoder}
\begin{code}
\captionof{listing}{Decoder fully implementing RV32I instructions}
\label{code:ID_decoder}  
\begin{minted}[fontsize=\footnotesize]{vhdl}
entity decoder is
    Port (
        clk         : in std_logic;
        instr       : in std_logic_vector(31 downto 0);
        op_class    : out std_logic_vector(4 downto 0);
        funct3      : out std_logic_vector(2 downto 0);
        funct7      : out std_logic_vector(6 downto 0);
        a_sel       : out std_logic;
        b_sel       : out std_logic;
        cond_opcode : out std_logic_vector(2 downto 0);
        imm_se      : out std_logic_vector(31 downto 0));
end decoder;

architecture Behavioral of decoder is    
begin
process(instr)
begin
case instr(6 downto 5) is
    when "00" =>
        case instr(4 downto 2) is 
            when "000"  =>              -- LOAD [I-type]
                op_class    <=  "00010";
                imm_se      <=  std_logic_vector(resize(signed(instr(31 downto 20)), imm_se'length)); -- Sign extension of the 12 bit immediate part 
                a_sel       <=  '1'; -- Select register as first operand 
                b_sel       <=  '0'; -- Select immediate as second operand
                funct3      <=  (others => 'Z'); -- Loads will perform additions anyway
                funct7      <=  (others => 'Z'); 
                cond_opcode <=  (others => 'Z');   
            when "100"  =>              -- OP-IMM [I-type]
                op_class    <=  "00001";
                imm_se      <=  std_logic_vector(resize(signed(instr(31 downto 20)), imm_se'length));
                a_sel       <=  '1';
                b_sel       <=  '0';
                funct3      <=  instr(14 downto 12);
                funct7      <=  instr(31 downto 25); -- shifts have funct7
                cond_opcode <=  (others => 'Z');    
            when "101"  =>              -- AUIPC (Add upper-immediate to Program Counter) [U-type] can be encoded as a jump
                op_class    <=  "01000";
                imm_se      <=  std_logic_vector(resize(signed(instr(31 downto 12)), imm_se'length));
                a_sel       <=  '0'; -- Select Program counter as first operand 
                b_sel       <=  '0'; -- Select immediate as second operand
                funct3      <=  "000"; -- Select add
                funct7      <=  (others => 'Z');  
                cond_opcode <=  (others => 'Z');                         
            when others =>
        end case;
    when "01" =>
        case instr(4 downto 2) is 
            when "000"  =>              -- STORE [S-type]
                op_class    <=  "00100";
                imm_se      <=  std_logic_vector(resize(signed(instr(31 downto 25) & instr(11 downto 7)), imm_se'length));
                a_sel       <=  '1';
                b_sel       <=  '1';
                funct3      <=  "000";
                funct7      <=  (others => 'Z'); 
                cond_opcode <=  (others => 'Z'); 
            when "100"  =>              -- OP [R-type]
                op_class    <=  "00001";
                imm_se      <=  (others => '0');
                a_sel       <=  '1';
                b_sel       <=  '1';
                funct3      <=  instr(14 downto 12);
                funct7      <=  instr(31 downto 25);
                cond_opcode <=  (others => 'Z'); 
            when "101"  =>              -- LUI [I-type]
                op_class    <=  "00010";
                imm_se      <=  std_logic_vector(resize(signed(instr(31 downto 20)), imm_se'length)); -- Sign extension of the 12 bit immediate part 
                a_sel       <=  '1'; -- Select register as first operand 
                b_sel       <=  '0'; -- Select immediate as second operand
                funct3      <=  "000";
                funct7      <=  (others => 'Z'); 
                cond_opcode <=  (others => 'Z');                       
            when others =>
        end case;    
    when "11" =>
        case instr(4 downto 2) is 
            when "000"  =>              -- BRANCH [B-type]
                op_class    <=  "10000";
                imm_se      <=  std_logic_vector(resize(signed(instr(31) & instr(7) & instr(30 downto 25) & instr(11 downto 8)), imm_se'length));
                a_sel       <=  '1';
                b_sel       <=  '1';
                funct3      <=  (others => 'Z'); 
                funct7      <=  (others => 'Z'); 
                cond_opcode <=  instr(14 downto 12); 
            when "001"  =>              -- JALR [J-type]
                op_class    <=  "01000";
                imm_se      <=  std_logic_vector(resize(signed(instr(31) & instr(19 downto 12) & instr(20) & instr(30 downto 21)), imm_se'length));
                a_sel       <=  '0';
                b_sel       <=  '0';
                funct3      <=  instr(14 downto 12);
                funct7      <=  (others => 'Z'); 
                cond_opcode <=  (others => 'Z'); 
            when "011"  =>              -- JAL
                op_class    <=  "01000";
                imm_se      <=  std_logic_vector(resize(signed(instr(31) & instr(19 downto 12) & instr(20) & instr(30 downto 21)), imm_se'length));
                a_sel       <=  '0';
                b_sel       <=  '0'; 
                funct3      <=  (others => 'Z'); 
                funct7      <=  (others => 'Z'); 
                cond_opcode <=  (others => 'Z');                      
            when others =>
                funct3      <=  (others => 'Z'); 
                funct7      <=  (others => 'Z'); 
                cond_opcode <=  (others => 'Z');  
        end case;   
    when others =>
        funct3      <=  (others => 'Z'); -- Loads will perform additions anyway
        funct7      <=  (others => 'Z'); 
        cond_opcode <=  (others => 'Z');  
end case;
end process;
end Behavioral;
\end{minted}
\end{code}


\subsubsection{Testbench}
\begin{code}
\captionof{listing}{Instruction Decode Testbench}
\label{code:ID_TB}  
\begin{minted}[fontsize=\footnotesize]{vhdl}
entity ID_testbench is
end ID_testbench;

architecture Behavioral of ID_testbench is
constant clk_period     : time := 100 ns;
signal pc_in            : std_logic_vector(11 downto 0) := (others => '0');
signal next_pc          : std_logic_vector(11 downto 0) := (others => '0');
signal next_pc_reg      : std_logic_vector(11 downto 0) := (others => '0');
signal curr_pc          : std_logic_vector(11 downto 0) := (others => '0');
signal instr            : std_logic_vector(31 downto 0) := (others => '0');
signal clk              : std_logic := '0';
signal pc_load_en       : std_logic := '1';

-- signals for the ID

signal rd_write_en      : std_logic := '0';
signal rd_value         : std_logic_vector(31 downto 0) := (others => '0');
signal next_pc_ze       : std_logic_vector(31 downto 0) := (others => '0');
signal curr_pc_ze       : std_logic_vector(31 downto 0) := (others => '0');
signal op_class         : std_logic_vector(4 downto 0) := (others => '0');
signal funct3           : std_logic_vector(2 downto 0) := (others => '0');
signal a_sel            : std_logic := '0';
signal b_sel            : std_logic := '0';
signal cond_opcode      : std_logic_vector(2 downto 0) := (others => '0');
signal rs1              : std_logic_vector(31 downto 0) := (others => '0');
signal rs2              : std_logic_vector(31 downto 0) := (others => '0');
signal imm_se           : std_logic_vector(31 downto 0) := (others => '0');
        
component instr_fetch
    port ( 
        clk         : in std_logic;
        pc_load_en  : in std_logic;
        pc_in       : in std_logic_vector(11 downto 0);
        
        next_pc     : out std_logic_vector(11 downto 0);
        curr_pc     : out std_logic_vector(11 downto 0);
        instr       : out std_logic_vector(31 downto 0));
end component;

component instr_decode
    port (
        clk         : in std_logic;
        instr       : in std_logic_vector(31 downto 0);
        next_pc     : in std_logic_vector(11 downto 0);
        curr_pc     : in std_logic_vector(11 downto 0);
        
        -- Inputs from mem writeback
        
        rd_write_en : in std_logic;
        rd_value    : in std_logic_vector(31 downto 0);
        
        -- sign-extended pc info
        
        next_pc_ze  : out std_logic_vector(31 downto 0);
        curr_pc_ze  : out std_logic_vector(31 downto 0);
        
        -- Decoded instruction informations
        
        op_class    : out std_logic_vector(4 downto 0);
        funct3      : out std_logic_vector(2 downto 0);
        a_sel       : out std_logic;
        b_sel       : out std_logic;
        cond_opcode : out std_logic_vector(2 downto 0);
        
        -- Data to be elaborated
        
        rs1         : out std_logic_vector(31 downto 0);
        rs2         : out std_logic_vector(31 downto 0);
        imm_se      : out std_logic_vector(31 downto 0));
end component;
begin
if_inst : instr_fetch
    port map (
        clk         => clk,
        pc_load_en  => pc_load_en,
        pc_in       => pc_in,
        next_pc     => next_pc,
        curr_pc     => curr_pc,
        instr       => instr);
    
id_inst : instr_decode
    port map (
        clk         => clk,
        instr       => instr,
        next_pc     => next_pc,
        curr_pc     => curr_pc,
        rd_write_en => rd_write_en,
        rd_value    => rd_value,
        next_pc_ze  => next_pc_ze,
        curr_pc_ze  => curr_pc_ze,
        op_class    => op_class,
        funct3      => funct3,
        a_sel       => a_sel,
        b_sel       => b_sel,
        cond_opcode => cond_opcode,
        rs1         => rs1,
        rs2         => rs2,
        imm_se      => imm_se);

process
begin
    clk <= '0';
    wait for clk_period / 2;
    clk <= '1';
    wait for clk_period / 2;
end process;
pc_in       <= next_pc;
end Behavioral;
    
\end{minted}
\end{code}
\newpage


\subsection{Instruction Execute [RV32I]}
\subsubsection{Architecture}
\begin{code}
\captionof{listing}{Architecture of Instruction Execute}
\label{code:IE_code}  
\begin{minted}[fontsize=\footnotesize]{vhdl}
    entity instr_exec is
    Port (
        a_sel           : in std_logic;
        b_sel           : in std_logic;    
        rs1             : in std_logic_vector(31 downto 0);
        rs2             : in std_logic_vector(31 downto 0);
        imm_se          : in std_logic_vector(31 downto 0);
        curr_pc         : in std_logic_vector(31 downto 0);
        cond_opcode     : in std_logic_vector(2 downto 0);
        funct3          : in std_logic_vector(2 downto 0);
        funct7          : in std_logic_vector(6 downto 0);
        op_class        : in std_logic_vector(4 downto 0);
        
        branch_cond     : out std_logic;
        alu_result      : out std_logic_vector(31 downto 0);
        ls_class        : out std_logic_vector(2 downto 0));
end instr_exec;

architecture Structural of instr_exec is
signal alu_mux_a    : std_logic_vector(31 downto 0);
signal alu_mux_b    : std_logic_vector(31 downto 0);

component ALU is
    port (
        first_operand   : in std_logic_vector(31 downto 0);
        second_operand  : in std_logic_vector(31 downto 0);
        funct3          : in std_logic_vector(2 downto 0);
        funct7          : in std_logic_vector(6 downto 0);
        op_class        : in std_logic_vector(4 downto 0);
        
        alu_result      : out std_logic_vector(31 downto 0);
        ls_class        : out std_logic_vector(2 downto 0));
end component;

component comparator is
    port ( 
        first_operand   : in std_logic_vector(31 downto 0);
        second_operand  : in std_logic_vector(31 downto 0);
        cond_opcode     : in std_logic_vector(2 downto 0);
        
        branch_cond     : out std_logic);
end component;
begin
comp : comparator 
port map(
    first_operand   => rs1,
    second_operand  => rs2,
    cond_opcode     => cond_opcode,
    branch_cond     => branch_cond); 

alu_1 : ALU
port map(
    first_operand   => alu_mux_a,
    second_operand  => alu_mux_b,
    funct3          => funct3,
    funct7          => funct7,
    op_class        => op_class,
        
    alu_result      => alu_result,
    ls_class        => ls_class);

alu_mux_a   <= rs1 when a_sel = '1' else curr_pc;
alu_mux_b   <= rs2 when b_sel = '1' else imm_se;
end Structural;
\end{minted}
\end{code}
\newpage


\subsubsection{ALU}
\begin{code}
\captionof{listing}{Arithmetic Logic Unit and Shifter}
\label{code:IE_ALU}  
\begin{minted}[fontsize=\footnotesize]{vhdl}
entity ALU is
    Port (
        first_operand   : in std_logic_vector(31 downto 0);
        second_operand  : in std_logic_vector(31 downto 0);
        funct3          : in std_logic_vector(2 downto 0);
        funct7          : in std_logic_vector(6 downto 0);
        op_class        : in std_logic_vector(4 downto 0);
        
        alu_result      : out std_logic_vector(31 downto 0);
        ls_class        : out std_logic_vector(2 downto 0)
    );
end ALU;

architecture Behavioral of ALU is
begin
process(op_class, funct3, funct7, first_operand, second_operand)
begin
    case op_class is
        when "00001" => --OP and OP-IMM
            case funct3 is
                when "001" => -- SLL,SLLI
                    alu_result <= std_logic_vector(shift_left(unsigned(first_operand),
                                        to_integer(unsigned(second_operand))));
                when "010" => -- SLT,SLTI
                    alu_result <= 
                        (0 => '1', others => '1')
                    when (unsigned(first_operand) < unsigned(second_operand)) else
                        (others => '0');
                when "011" => -- SLTU,SLTIU
                    alu_result <= 
                        (0 => '1', others => '1')
                    when (unsigned(first_operand) < unsigned(second_operand)) else
                        (others => '0');
                when "100" => -- XOR, XORI
                    alu_result <= first_operand xor second_operand;
                when "101" => -- right shifts
                    alu_result     <= 
                    std_logic_vector(shift_right(unsigned(first_operand), 
                                        to_integer(unsigned(second_operand(4 downto 0)))))
                    when funct7(5) = '1' else
                    std_logic_vector(shift_right(signed(first_operand), 
                                        to_integer(unsigned(second_operand(4 downto 0)))));
                when "110" => -- OR,ORI
                    alu_result      <= first_operand or second_operand;
                when "111" => -- AND, ANDI
                    alu_result      <= first_operand and second_operand;
                when others =>
                    alu_result <= 
                        std_logic_vector(signed(first_operand) - signed(second_operand))
                    when funct7(5) = '1' else
                        std_logic_vector(signed(first_operand) + signed(second_operand));
            end case;
        when "00010" => -- LOAD
            case funct3 is
                when "000" => -- LB
                    alu_result <= std_logic_vector(signed(first_operand) + signed(second_operand));
                    ls_class <=  "001";
                when "001" => -- LH
                    alu_result <= std_logic_vector(signed(first_operand) + signed(second_operand));
                    ls_class <=  "010";
                when "010" => -- LW
                    alu_result <= std_logic_vector(signed(first_operand) + signed(second_operand));
                    ls_class <=  "100";
                when "100" => -- LBU
                    alu_result <= std_logic_vector(unsigned(first_operand) + unsigned(second_operand));
                    ls_class <=  "001";
                when "101" => -- LHU
                    alu_result <= std_logic_vector(unsigned(first_operand) + unsigned(second_operand));
                    ls_class <=  "010";
                when others =>
                    alu_result <= std_logic_vector(signed(first_operand) + signed(second_operand));
                    ls_class <=  "001";
            end case;
        when "00100" => -- STORE
            case funct3 is
                when "000" => -- SB
                    alu_result <= std_logic_vector(signed(first_operand) + signed(second_operand));
                    ls_class <=  "001";
                when "001" => -- SH
                    alu_result <= std_logic_vector(signed(first_operand) + signed(second_operand));
                    ls_class <=  "010";
                when "010" => -- SW
                    alu_result <= std_logic_vector(signed(first_operand) + signed(second_operand));
                    ls_class <=  "100";
                when others =>
                    alu_result <= std_logic_vector(signed(first_operand) + signed(second_operand));
                    ls_class <=  "001";
            end case;
        when others => -- BRANCH, JUMP or undefined sequences may just lead to an addition 
                        --  which may or may not be considered
            alu_result <= std_logic_vector(unsigned(first_operand) + unsigned(second_operand));
    end case;
end process;
end Behavioral;
\end{minted}
\end{code}

\subsubsection{Comparator}
\begin{code}
\captionof{listing}{Comparator}
\label{code:IE_comparator}  
\begin{minted}[fontsize=\footnotesize]{vhdl}
entity comparator is
    port ( 
        first_operand   : in std_logic_vector(31 downto 0);
        second_operand  : in std_logic_vector(31 downto 0);
        cond_opcode     : in std_logic_vector(2 downto 0);
        
        branch_cond     : out std_logic);
end comparator;

architecture Behavioral of comparator is
begin
    process(cond_opcode, first_operand, second_operand)
    begin
        case cond_opcode is
            when "000"  =>          -- EQ
                if first_operand = second_operand then 
                    branch_cond <= '1';
                end if;
            when "001"  =>          -- NEQ
                if not(first_operand = second_operand) then 
                    branch_cond <= '1';
                end if;
            when "100"  =>          -- LT lower than
                if signed(first_operand) < signed(second_operand) then 
                    branch_cond <= '1';
                end if;
            when "101"  =>          -- GE greater or equal
                if signed(first_operand) >= signed(second_operand) then 
                    branch_cond <= '1';
                end if;
            when "110"  =>          -- LT unsigned
                if unsigned(first_operand) < unsigned(second_operand) then 
                    branch_cond <= '1';
                end if;
            when "111"  =>          -- GE unsigned
                if unsigned(first_operand) >= unsigned(second_operand) then 
                    branch_cond <= '1';
                end if;
            when others =>
                branch_cond <= '0';
        end case;
    end process;
end Behavioral;
\end{minted}
\end{code}
\newpage


\subsubsection{Testbench}
\begin{code}
\captionof{listing}{Instruction Execute Testbench}
\label{code:IE_TB}  
\begin{minted}[fontsize=\footnotesize]{vhdl}
entity IE_testbench is
end IE_testbench;

architecture Behavioral of IE_testbench is
constant clk_period     : time := 100 ns;
signal pc_in            : std_logic_vector(11 downto 0) := (others => '0');
signal next_pc          : std_logic_vector(11 downto 0) := (others => '0');
signal next_pc_reg      : std_logic_vector(11 downto 0) := (others => '0');
signal curr_pc          : std_logic_vector(11 downto 0) := (others => '0');
signal instr            : std_logic_vector(31 downto 0) := (others => '0');
signal clk              : std_logic := '0';
signal pc_load_en       : std_logic := '1';

-- signals for the ID

signal rd_write_en      : std_logic := '0';
signal rd_value         : std_logic_vector(31 downto 0) := (others => '0');
signal next_pc_ze       : std_logic_vector(31 downto 0) := (others => '0');
signal curr_pc_ze       : std_logic_vector(31 downto 0) := (others => '0');
signal op_class         : std_logic_vector(4 downto 0) := (others => '0');
signal funct3           : std_logic_vector(2 downto 0) := (others => '0');
signal a_sel            : std_logic := '0';
signal b_sel            : std_logic := '0';
signal cond_opcode      : std_logic_vector(2 downto 0) := (others => '0');
signal rs1              : std_logic_vector(31 downto 0) := (others => '0');
signal rs2              : std_logic_vector(31 downto 0) := (others => '0');
signal imm_se           : std_logic_vector(31 downto 0) := (others => '0');

--signals for the IE
signal funct7           : std_logic_vector(6 downto 0) := (others => '0');
signal branch_cond      : std_logic := '0';
signal ls_class         : std_logic_vector(2 downto 0) := (others => '0');
signal alu_result       : std_logic_vector(31 downto 0) := (others => '0');

component instr_fetch
    port ( 
        clk         : in std_logic;
        pc_load_en  : in std_logic;
        pc_in       : in std_logic_vector(11 downto 0);
        
        next_pc     : out std_logic_vector(11 downto 0);
        curr_pc     : out std_logic_vector(11 downto 0);
        instr       : out std_logic_vector(31 downto 0));
end component;

component instr_decode
    port (
        clk         : in std_logic;
        instr       : in std_logic_vector(31 downto 0);
        next_pc     : in std_logic_vector(11 downto 0);
        curr_pc     : in std_logic_vector(11 downto 0);
        
        -- Inputs from mem writeback
        
        rd_write_en : in std_logic;
        rd_value    : in std_logic_vector(31 downto 0);
        
        -- sign-extended pc info
        
        next_pc_ze  : out std_logic_vector(31 downto 0);
        curr_pc_ze  : out std_logic_vector(31 downto 0);
        
        -- Decoded instruction informations
        
        op_class    : out std_logic_vector(4 downto 0);
        funct3      : out std_logic_vector(2 downto 0);
        funct7      : out std_logic_vector(6 downto 0);
        a_sel       : out std_logic;
        b_sel       : out std_logic;
        cond_opcode : out std_logic_vector(2 downto 0);
        
        -- Data to be elaborated
        
        rs1         : out std_logic_vector(31 downto 0);
        rs2         : out std_logic_vector(31 downto 0);
        imm_se      : out std_logic_vector(31 downto 0));
end component;
    
component instr_exec
    port(
        a_sel           : in std_logic;
        b_sel           : in std_logic;    
        rs1             : in std_logic_vector(31 downto 0);
        rs2             : in std_logic_vector(31 downto 0);
        imm_se          : in std_logic_vector(31 downto 0);
        curr_pc         : in std_logic_vector(31 downto 0);
        cond_opcode     : in std_logic_vector(2 downto 0);
        funct3          : in std_logic_vector(2 downto 0);
        funct7          : in std_logic_vector(6 downto 0);
        op_class        : in std_logic_vector(4 downto 0);
        
        branch_cond     : out std_logic;
        alu_result      : out std_logic_vector(31 downto 0);
        ls_class        : out std_logic_vector(2 downto 0));
end component;
begin

    if_inst : instr_fetch
        port map (
            clk         => clk,
            pc_load_en  => pc_load_en,
            pc_in       => pc_in,
            next_pc     => next_pc,
            curr_pc     => curr_pc,
            instr       => instr);
        
    id_inst : instr_decode
        port map (
            clk         => clk,
            instr       => instr, 
            next_pc     => next_pc,
            curr_pc     => curr_pc,
            rd_write_en => rd_write_en,
            rd_value    => rd_value, 
            next_pc_ze  => next_pc_ze,
            curr_pc_ze  => curr_pc_ze,
            op_class    => op_class,
            funct3      => funct3,
            funct7      => funct7,
            a_sel       => a_sel,
            b_sel       => b_sel,
            cond_opcode => cond_opcode,
            rs1         => rs1,
            rs2         => rs2,
            imm_se      => imm_se);
    ie_inst : instr_exec
        port map(
            a_sel       => a_sel,
            b_sel       => b_sel,
            rs1         => rs1,
            rs2         => rs2,
            imm_se      => imm_se,
            curr_pc     => curr_pc_ze,
            cond_opcode => cond_opcode,
            funct3      => funct3,
            funct7      => funct7,
            op_class    => op_class,
            branch_cond => branch_cond,
            ls_class    => ls_class);
        
    process
    begin
        clk <= '0';
        wait for clk_period / 2;
        clk <= '1';
        wait for clk_period / 2;
    end process;

    pc_in       <= next_pc;
end Behavioral;
\end{minted}
\end{code}
\newpage


\subsection{Data Memory}

\subsection{WriteBack}